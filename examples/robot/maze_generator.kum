использовать Робот

| Генератор случайного лабиринта и поиск выхода
| Алгоритм генерации: рекурсивный backtracking
| Алгоритм поиска: правило правой руки
|
| Робот стартует в левом верхнем углу (0,0)
| Цель — дойти до правого нижнего угла

| Параметры лабиринта
цел ШИРИНА = 15
цел ВЫСОТА = 15

алг
нач
    | Генерируем лабиринт и сохраняем в файл
    вывод "Генерация лабиринта ", ШИРИНА, "x", ВЫСОТА, "...", нс
    генерировать_лабиринт
    вывод "Лабиринт создан", нс

    | Теперь ищем выход (робот загрузит файл при первой команде)
    вывод "Поиск выхода...", нс
    искать_выход
    вывод "Готово!", нс
кон

| Генерация лабиринта алгоритмом рекурсивного backtracking
алг генерировать_лабиринт
нач
    цел x, y

    | Массивы для хранения стен
    | wallRight[x,y] = 1 если есть стена справа от (x,y)
    | wallDown[x,y] = 1 если есть стена снизу от (x,y)
    цел таб wallRight[0:ШИРИНА-1, 0:ВЫСОТА-1]
    цел таб wallDown[0:ШИРИНА-1, 0:ВЫСОТА-1]
    цел таб visited[0:ШИРИНА-1, 0:ВЫСОТА-1]

    | Изначально все стены стоят, ничего не посещено
    нц для y от 0 до ВЫСОТА - 1
        нц для x от 0 до ШИРИНА - 1
            wallRight[x, y] := 1
            wallDown[x, y] := 1
            visited[x, y] := 0
        кц
    кц

    | Итеративный DFS со стеком
    цел таб стекX[1:ШИРИНА*ВЫСОТА], стекY[1:ШИРИНА*ВЫСОТА]
    цел верх

    верх := 1
    стекX[1] := 0
    стекY[1] := 0
    visited[0, 0] := 1

    нц пока верх > 0
        цел cx, cy
        cx := стекX[верх]
        cy := стекY[верх]

        | Перемешиваем направления
        цел таб dirs[0:3]
        dirs[0] := 0; dirs[1] := 1; dirs[2] := 2; dirs[3] := 3
        цел i, j, t
        нц для i от 3 до 1 шаг -1
            j := rnd(i + 1)
            t := dirs[i]; dirs[i] := dirs[j]; dirs[j] := t
        кц

        | Ищем непосещённого соседа
        цел найден, nx = 0, ny = 0, напр = 0
        найден := 0

        нц для i от 0 до 3
            напр := dirs[i]
            выбор
                при напр = 0: nx := cx; ny := cy - 1     | вверх
                при напр = 1: nx := cx + 1; ny := cy     | вправо
                при напр = 2: nx := cx; ny := cy + 1     | вниз
                при напр = 3: nx := cx - 1; ny := cy     | влево
            все

            если nx >= 0 и nx < ШИРИНА и ny >= 0 и ny < ВЫСОТА
                то
                    если visited[nx, ny] = 0
                        то
                            найден := 1
                            выход
                    все
            все
        кц

        если найден = 1
            то
                | Убираем стену между (cx,cy) и (nx,ny)
                выбор
                    при напр = 0:  | вверх
                        wallDown[cx, cy - 1] := 0
                    при напр = 1:  | вправо
                        wallRight[cx, cy] := 0
                    при напр = 2:  | вниз
                        wallDown[cx, cy] := 0
                    при напр = 3:  | влево
                        wallRight[cx - 1, cy] := 0
                все

                | Добавляем соседа в стек
                visited[nx, ny] := 1
                верх := верх + 1
                стекX[верх] := nx
                стекY[верх] := ny
            иначе
                | Backtrack
                верх := верх - 1
        все
    кц

    | Сохраняем лабиринт в файл
    файл ф
    ф := открыть на запись("maze.fil")

    | Размер и позиция робота
    вывод ф, ШИРИНА, " ", ВЫСОТА, нс
    вывод ф, "0 0", нс

    | Записываем клетки со стенами
    нц для y от 0 до ВЫСОТА - 1
        нц для x от 0 до ШИРИНА - 1
            цел wE, wS
            wE := 0; wS := 0

            если x < ШИРИНА - 1
                то wE := wallRight[x, y]
            все
            если y < ВЫСОТА - 1
                то wS := wallDown[x, y]
            все

            если wE = 1 или wS = 1
                то
                    | x y WallN WallE WallS WallW Painted PointMark Rad Temp R G B
                    вывод ф, x, " ", y, " 0 ", wE, " ", wS, " 0 0 0 0 0 0 0 0", нс
            все
        кц
    кц

    закрыть(ф)
кон

| Поиск выхода по правилу правой руки
| Закрашиваем клетки по пути
алг искать_выход
нач
    цел направление
    направление := 2  | начинаем смотря на юг

    цел шагов, pos_x, pos_y
    шагов := 0
    pos_x := 0
    pos_y := 0

    нц пока не (pos_x = ШИРИНА - 1 и pos_y = ВЫСОТА - 1)
        закрасить

        | Правило правой руки: сначала пробуем направо
        цел правое
        правое := mod(направление + 1, 4)

        если можно_идти(правое)
            то
                направление := правое
                сделать_шаг(направление, pos_x, pos_y)
            иначе
                если можно_идти(направление)
                    то
                        сделать_шаг(направление, pos_x, pos_y)
                    иначе
                        цел левое
                        левое := mod(направление + 3, 4)
                        если можно_идти(левое)
                            то
                                направление := левое
                                сделать_шаг(направление, pos_x, pos_y)
                            иначе
                                направление := mod(направление + 2, 4)
                        все
                все
        все

        шагов := шагов + 1
        если шагов > ШИРИНА * ВЫСОТА * 10
            то
                вывод "Превышен лимит шагов", нс
                выход
        все
    кц

    закрасить
    вывод "Шагов: ", шагов, нс
кон

| Проверить можно ли идти
алг лог можно_идти(цел напр)
нач
    выбор
        при напр = 0: знач := сверху свободно
        при напр = 1: знач := справа свободно
        при напр = 2: знач := снизу свободно
        при напр = 3: знач := слева свободно
    все
кон

| Сделать шаг и обновить позицию
алг сделать_шаг(цел напр, арг рез цел x, арг рез цел y)
нач
    выбор
        при напр = 0:
            вверх
            y := y - 1
        при напр = 1:
            вправо
            x := x + 1
        при напр = 2:
            вниз
            y := y + 1
        при напр = 3:
            влево
            x := x - 1
    все
кон
