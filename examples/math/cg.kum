алг main
нач
  | Conjugate Gradient (CG) для матрицы Гильберта A (A[i,j] = 1/(i+j+1)) и правой части b=1.
  | Один модуль: инициализация → решение → проверка → печать норм невязки.

  | параметры
  цел n, maxIter
  вещ tol
  n := 64              | размер (берите больше, если нужно)
  maxIter := 500       | максимум итераций CG
  tol := 0.0000000001  | допуск по норме невязки

  | векторы
  вещ таб x[0:n-1]      | решение
  вещ таб b[0:n-1]      | правая часть
  вещ таб r[0:n-1]      | текущая невязка r = b - A x
  вещ таб p[0:n-1]      | направление спуска
  вещ таб Ap[0:n-1]     | A * p

  | служебные
  цел i, it
  вещ rsold, rsnew, alpha, pAp, rnorm, vabs

  | b := 1, x := 0
  нц для i от 0 до n-1
    b[i] := 1.0
    x[i] := 0.0
  кц

  | начальная невязка и начальное направление
  compute_residual(n, x, b, r, Ap)
  нц для i от 0 до n-1
    p[i] := r[i]
  кц
  rsold := dot(n, r, r)

  it := 0
  нц пока it < maxIter
    | Ap := A * p
    matvec(n, p, Ap)
    pAp := dot(n, p, Ap)
    если pAp = 0.0 то выход все
    alpha := rsold / pAp

    | x := x + alpha * p; r := r - alpha * Ap
    нц для i от 0 до n-1
      x[i] := x[i] + alpha * p[i]
      r[i] := r[i] - alpha * Ap[i]
    кц

    rnorm := norm2(n, r)
    если rnorm <= tol то выход все

    rsnew := dot(n, r, r)
    если rsold <> 0.0 то
      | p := r + (rsnew/rsold) * p
      вещ beta
      beta := rsnew / rsold
      нц для i от 0 до n-1
        p[i] := r[i] + beta * p[i]
      кц
    иначе
      | rsold == 0: возьмём p := r
      нц для i от 0 до n-1
        p[i] := r[i]
      кц
    все

    rsold := rsnew
    it := it + 1
  кц

  | финальная невязка и её нормы
  compute_residual(n, x, b, r, Ap)
  вещ res_l2_sq, res_l2, res_inf
  res_l2_sq := 0.0
  res_inf := 0.0
  нц для i от 0 до n-1
    vabs := r[i]; если vabs < 0.0 то vabs := -vabs все
    res_l2_sq := res_l2_sq + r[i] * r[i]
    если vabs > res_inf то res_inf := vabs все
  кц
  res_l2 := sqrt(res_l2_sq)

  вывод "cg: n=", n, ", maxIter=", maxIter, нс
  вывод "iters=", it, нс
  вывод "||r||_2= ", res_l2, нс
  вывод "||r||_inf= ", res_inf, нс
кон

| ---- Вспомогательные процедуры/функции ----

| матрично-векторное произведение для матрицы Гильберта: w = A * v,
| A[i,j] = 1/(i+j+1), i,j=0..n-1
алг matvec(цел n, вещ таб v[0:n-1], рез вещ таб w[0:n-1])
нач
  цел i, j
  вещ sum
  нц для i от 0 до n-1
    sum := 0.0
    нц для j от 0 до n-1
      sum := sum + (1.0 / (i + j + 1.0)) * v[j]
    кц
    w[i] := sum
  кц
кон

| евклидова норма ||v||_2
алг вещ norm2(цел n, вещ таб v[0:n-1])
нач
  цел i
  вещ sum
  sum := 0.0
  нц для i от 0 до n-1
    sum := sum + v[i] * v[i]
  кц
  знач := sqrt(sum)
кон

| скалярное произведение <a,b>
алг вещ dot(цел n, вещ таб a[0:n-1], вещ таб b[0:n-1])
нач
  цел i
  вещ sum
  sum := 0.0
  нц для i от 0 до n-1
    sum := sum + a[i] * b[i]
  кц
  знач := sum
кон

| r := b - A*x (использует matvec с временным буфером w)
алг compute_residual(цел n, вещ таб x[0:n-1], вещ таб b[0:n-1], рез вещ таб r[0:n-1], вещ таб w[0:n-1])
нач
  цел i
  matvec(n, x, w)
  нц для i от 0 до n-1
    r[i] := b[i] - w[i]
  кц
кон
