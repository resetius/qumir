алг
нач
  | Ланцош для симметричного оператора A = (−Δ_h) с Дирихле в 2D на [0,1]^2.
  | Цель: получить несколько наименьших собственных значений (ритц‑значения) и сравнить с аналитикой.

  цел Nx, Ny
  Nx := 32
  Ny := 32
  вещ h, h2, pi
  pi := 3.141592653589793
  h := 1.0 / (Nx - 1)
  h2 := h * h

  | Число внутренних узлов и длина вектора состояния: (Nx-2)*(Ny-2)
  цел NI, NJ, N
  NI := Nx - 2
  NJ := Ny - 2
  N := NI * NJ

  | Параметры Ланцоша
  цел m, want
  m := 100      | размер подпространства Крылова (больше для лучшей точности)
  want := 5     | cколько наименьших значений хотим

  | Вектора и рабочие буферы
  вещ таб v0[0:N-1], v1[0:N-1], w[0:N-1]
  вещ таб Q[0:m-1, 0:N-1]      | база Ланцоша (для векторов на будущее)
  вещ таб alpha[0:m-1], beta[0:m-2]

  цел i, j, k, t, r
  вещ s, nrm, inv, a, b, lo, hi, mid, cnt

  | Инициализация начального вектора (случайный/гладкий) и нормализация
  | Возьмём v0[i] = sin(π x) sin(π y) как неплохое стартовое приближение
  t := 0
  нц для i от 1 до NI шаг 1
    нц для j от 1 до NJ шаг 1
      v0[t] := sin(pi * (i * h)) * sin(pi * (j * h)) + 0.5 * sin(pi * (2.0 * i * h)) * sin(pi * (j * h)) + 0.5 * sin(pi * (i * h)) * sin(pi * (2.0 * j * h))
      t := t + 1
    кц
  кц
  nrm := 0.0
  нц для i от 0 до N-1 шаг 1
    nrm := nrm + v0[i] * v0[i]
  кц
  nrm := sqrt(nrm)
  inv := 1.0 / nrm
  нц для i от 0 до N-1 шаг 1
    v0[i] := v0[i] * inv
    Q[0,i] := v0[i]
  кц

  | Ланцош цикл
  | beta[-1] = 0, v_{-1} не определён
  | w = A v0
  matvec_A(Nx, Ny, N, h2, v0, w)
  alpha[0] := dot(N, v0, w)
  нц для i от 0 до N-1 шаг 1
    w[i] := w[i] - alpha[0] * v0[i]
  кц
  | Однопроходная реортогонализация для численной устойчивости
  s := 0.0
  нц для i от 0 до N-1 шаг 1
    s := s + Q[0,i] * w[i]
  кц
  нц для i от 0 до N-1 шаг 1
    w[i] := w[i] - s * Q[0,i]
  кц
  если m > 1 то
    beta[0] := norm2(N, w)
  все

  нц для k от 1 до m-1 шаг 1
    если beta[k-1] = 0 то
      | ранг меньше k, досрочно завершаем заполнение
      alpha[k] := 0
      выход
    все
    inv := 1.0 / beta[k-1]
    нц для i от 0 до N-1 шаг 1
      v1[i] := w[i] * inv
      Q[k,i] := v1[i]
    кц
    matvec_A(Nx, Ny, N, h2, v1, w)
    нц для i от 0 до N-1 шаг 1
      w[i] := w[i] - beta[k-1] * Q[k-1,i]
    кц
    alpha[k] := dot(N, v1, w)
    нц для i от 0 до N-1 шаг 1
      w[i] := w[i] - alpha[k] * v1[i]
    кц
    | Однопроходная реортогонализация по всем предыдущим векторам Q[0..k]
    нц для r от 0 до k шаг 1
      s := 0.0
      нц для i от 0 до N-1 шаг 1
        s := s + Q[r,i] * w[i]
      кц
      нц для i от 0 до N-1 шаг 1
        w[i] := w[i] - s * Q[r,i]
      кц
    кц
    если k < m-1 то
      beta[k] := norm2(N, w)
    все
    | v0 <- v1 для следующей итерации
    нц для i от 0 до N-1 шаг 1
      v0[i] := v1[i]
    кц
  кц

  | Найдём наименьшие собственные значения тридиагонали T с помощью бисекции и счёта Штурма
  | Оценки спектра (Гершгорин): [lo, hi]
  a := alpha[0]
  b := alpha[0]
  s := 0.0
  нц для k от 0 до m-1 шаг 1
    если alpha[k] < a то a := alpha[k] все
    если alpha[k] > b то b := alpha[k] все
    если k < m-1 и beta[k] > s то s := beta[k] все
  кц
  lo := a - 2.0 * s
  hi := b + 2.0 * s

  вещ таб evals[0:want-1]
  вещ eps
  eps := 1e-10

  нц для t от 1 до want шаг 1
    a := lo
    b := hi
    | ищем t‑е по возрастанию собственное значение
    нц для j от 0 до 80 шаг 1
      mid := 0.5 * (a + b)
      cnt := sturm_count(m, alpha, beta, mid)
      если cnt >= t то
        b := mid
      иначе
        a := mid
      все
    кц
    evals[t-1] := 0.5 * (a + b)
  кц

  | Вывод результатов и сравнение с аналитикой для первых мод (1,1), (1,2), (2,1), (1,3), (2,2)
  вывод "Lanczos2D: N=", Nx, "x", Ny, ", m=", m, ", want=", want, "\n"
  нц для t от 0 до want-1 шаг 1
    вывод "  λ[", t+1, "] ≈ ", evals[t], "\n"
  кц

  | Аналитические значения для 2D Лапласиана: λ_{p,q} = (4/h^2)(sin^2(π p/(2(Nx-1))) + sin^2(π q/(2(Ny-1))))
  вещ lam11, lam12, lam21, lam13, lam22
  lam11 := (4.0 / h2) * (sin(pi * 1.0 / (2.0 * (Nx - 1)))**2 + sin(pi * 1.0 / (2.0 * (Ny - 1)))**2)
  lam12 := (4.0 / h2) * (sin(pi * 1.0 / (2.0 * (Nx - 1)))**2 + sin(pi * 2.0 / (2.0 * (Ny - 1)))**2)
  lam21 := (4.0 / h2) * (sin(pi * 2.0 / (2.0 * (Nx - 1)))**2 + sin(pi * 1.0 / (2.0 * (Ny - 1)))**2)
  lam13 := (4.0 / h2) * (sin(pi * 1.0 / (2.0 * (Nx - 1)))**2 + sin(pi * 3.0 / (2.0 * (Ny - 1)))**2)
  lam22 := (4.0 / h2) * (sin(pi * 2.0 / (2.0 * (Nx - 1)))**2 + sin(pi * 2.0 / (2.0 * (Ny - 1)))**2)
  вывод "Analytic few (unordered): ", lam11, ", ", lam12, ", ", lam21, ", ", lam13, ", ", lam22, "\n"
кон

алг вещ dot(цел N, вещ таб x[0:N-1], вещ таб y[0:N-1])
нач
  вещ s
  цел i
  s := 0.0
  нц для i от 0 до N-1 шаг 1
    s := s + x[i] * y[i]
  кц
  знач := s
кон

алг вещ norm2(цел N, вещ таб x[0:N-1])
нач
  вещ s
  цел i
  s := 0.0
  нц для i от 0 до N-1 шаг 1
    s := s + x[i] * x[i]
  кц
  s := sqrt(s)
  знач := s
кон

алг цел idx(цел i, цел j, цел NI, цел NJ)
нач
  | i=1..NI, j=1..NJ → 0..N-1
  знач := (i - 1) * NJ + (j - 1)
кон

алг matvec_A(цел Nx, цел Ny, цел N, вещ h2, вещ таб x[0:N-1], вещ таб y[0:N-1])
нач
  | y = A x, A = (4 u - sum_neigh)/h^2, Дирихле 0 на границе
  цел NI, NJ
  NI := Nx - 2
  NJ := Ny - 2
  цел i, j, t
  вещ c, s
  нц для t от 0 до N-1 шаг 1
    y[t] := 0.0
  кц
  нц для i от 1 до NI шаг 1
    нц для j от 1 до NJ шаг 1
      c := 4.0 * x[idx(i,j,NI,NJ)]
      если i > 1 то c := c - x[idx(i-1,j,NI,NJ)] все
      если i < NI то c := c - x[idx(i+1,j,NI,NJ)] все
      если j > 1 то c := c - x[idx(i,j-1,NI,NJ)] все
      если j < NJ то c := c - x[idx(i,j+1,NI,NJ)] все
      y[idx(i,j,NI,NJ)] := c / h2
    кц
  кц
кон

алг цел sturm_count(цел m, вещ таб alpha[0:m-1], вещ таб beta[0:m-2], вещ lam)
нач
  | Счёт Штурма через LDL' рекурсию: d0 = a0 - lam; di = ai - lam - (bi-1^2)/d{i-1}
  цел i, count
  вещ d, prev
  count := 0
  d := alpha[0] - lam
  если d < 0.0 то count := count + 1 все
  нц для i от 1 до m-1 шаг 1
    | избегаем деления на ноль: если |d| очень мало, слегка отодвинем
    если abs(d) < 1e-14 то
      если d >= 0.0 то d := 1e-14 иначе d := -1e-14 все
    все
    d := alpha[i] - lam - (beta[i-1] * beta[i-1]) / d
    если d < 0.0 то count := count + 1 все
  кц
  знач := count
кон
