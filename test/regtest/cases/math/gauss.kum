алг main
нач
  | Решение Ax=b методом Гаусса с частичным выбором, нормировкой строки
  | и обратным ходом с делением на диагональ. Матрица Гильберта, b=1.
  | Вектор решения записывается в B. В конце выводятся нормы невязки.

  | параметры
  цел n
  вещ Eps
  n := 64
  Eps := 0.000000000001        | относительный порог по масштабу строки

  | данные
  вещ таб A[0:n-1,0:n-1]
  вещ таб B[0:n-1]

  | служебные
  цел i, j, k, _imax, t
  вещ p, tmp, bestSq, curSq, sum, rowmax, scale

  | инициализация: A(i,j) = 1/(i+j+1), B(i) = 1
  нц для i от 0 до n-1
    нц для j от 0 до n-1
      A[i,j] := 1.0 / (i + j + 1.0)
    кц
    B[i] := 1.0
  кц

  | прямой ход Гаусса с частичным выбором; НОРМИРУЕМ всегда
  нц для k от 0 до n-1
    | выбор ведущей строки по максимуму |A[i,k]|
    _imax := k
    bestSq := A[k,k] * A[k,k]
    нц для i от k+1 до n-1
      curSq := A[i,k] * A[i,k]
      если curSq > bestSq то
        bestSq := curSq
        _imax := i
      все
    кц

    | swap k <-> _imax
    если _imax <> k то
      нц для j от k до n-1
        tmp := A[k,j]
        A[k,j] := A[_imax,j]
        A[_imax,j] := tmp
      кц
      tmp := B[k]; B[k] := B[_imax]; B[_imax] := tmp
    все

    p := A[k,k]

    | относительная проверка на вырожденность: |p| <= Eps * max_j |A[k,j]|
    rowmax := 0.0
    нц для j от k до n-1
      sum := A[k,j]; если sum < 0.0 то sum := -sum все
      если sum > rowmax то rowmax := sum все
    кц
    scale := Eps * rowmax
    sum := p; если sum < 0.0 то sum := -sum все
    если sum <= scale то
      | почти нулевой пивот — прекращаем исключение
      выход
    все

    | нормируем ведущую строку k
    нц для j от k до n-1
      A[k,j] := A[k,j] / p
    кц
    B[k] := B[k] / p

    | исключаем ниже
    нц для i от k+1 до n-1
      tmp := A[i,k]
      если tmp <> 0.0 то
        нц для j от k до n-1
          A[i,j] := A[i,j] - A[k,j] * tmp
        кц
        B[i] := B[i] - B[k] * tmp
      все
    кц
  кц

  | обратный ход
  нц для t от 0 до n-1
    i := n - 1 - t
    sum := B[i]
    нц для j от i+1 до n-1
      sum := sum - A[i,j] * B[j]
    кц
    если A[i,i] <> 0.0 то
      B[i] := sum / A[i,i]
    иначе
      B[i] := 0.0
    все
  кц

  | === расчёт невязки r = A_orig * X - 1 ===
  вещ res_l2_sq, res_l2, res_inf, r, absv
  res_l2_sq := 0.0
  res_inf := 0.0
  нц для i от 0 до n-1
    sum := 0.0
    нц для j от 0 до n-1
      sum := sum + (1.0 / (i + j + 1.0)) * B[j]   | A_orig * x
    кц
    r := sum - 1.0                                  | вычитаем b_orig
    absv := r; если absv < 0.0 то absv := -absv все
    res_l2_sq := res_l2_sq + r * r
    если absv > res_inf то res_inf := absv все
  кц
  res_l2 := sqrt(res_l2_sq)

  | выводим нормы невязки
  вывод "||r||_2^2 = ", res_l2_sq, нс
  вывод "||r||_2    = ", res_l2, нс
  вывод "||r||_inf  = ", res_inf, нс
кон

